#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <math.h>

#include "util.h"

int inhib_status = 0;
int n_atom_init = 0 , new_atoms_each_second = 0 , atomic_sum_created_each_second = 0 , explode_threshold = 0;

int shmSemId = -1 , inhibMsgId = -1 , logFd = -1;
int* shm_ptr;

void calcActivation(int TOTfission , int TOTscorie , int energyProducedLastSec){
    static int time = 0;
    static int inhibPercentage = 10;

    static int last_energy_expected = 0;

    float neg_inhib_percentage = ((100 - inhibPercentage) / (float)100);
    float neg_inhib_percentage_squared = neg_inhib_percentage * neg_inhib_percentage;

    // number of atoms currently existing
    int old_atom_count = n_atom_init + TOTfission + (new_atoms_each_second * (time++)) - TOTscorie; 
    // number of atoms in the next iteration
    int new_atom_count = old_atom_count + new_atoms_each_second;

    float div = neg_inhib_percentage_squared * old_atom_count;
    // how much energy was generated by each atom in the last second (excluding the effect of the inhibitor)
    int average_fission_energy_last_sec = div == 0 ? 0 : energyProducedLastSec / div;
    // average atomic number of the current iteration
    int old_atomic_num = 1 + sqrt(1 + 4 * average_fission_energy_last_sec); 
    // average atomic number of the next iteration
    int new_atomic_num = (old_atomic_num * old_atom_count + atomic_sum_created_each_second) / new_atom_count;
    // energy that will be produced by each atom 
    int average_fission_energy_next_sec = new_atomic_num * (new_atomic_num - 1);
    // total energy that will be produced
    int energy_expected = new_atom_count * average_fission_energy_next_sec * neg_inhib_percentage_squared; 
    // averages over the last cycle
    last_energy_expected = energy_expected = (energy_expected + last_energy_expected) / 2;

    while (semop(shmSemId, &decSem, 1) == -1) {
        if(errno != EINTR){
            error("inibitore: Error in semop (preRead) semid = %d\t" , shmSemId);
            term(getppid() , GENERIC_ERR);
        }
    }

    if(inhib_status){
        int old_percentage = inhibPercentage;
        int net_energy = shm_ptr[SHM_STORED_ENERGY];
        if(explode_threshold == net_energy){
            inhibPercentage = 100;
        }else{
            inhibPercentage = (energy_expected * 100) / (float)(explode_threshold - net_energy);
            if(inhibPercentage < 0) inhibPercentage = 0;
            if(inhibPercentage > 100) inhibPercentage = 100;
        }
        if(old_percentage != inhibPercentage && writeLog(logFd, "Inhibition percentage changed to %d%%\n", inhibPercentage) == -1){
            error("inibitore: writeLog()");
            term(getppid() , GENERIC_ERR);
        }
    }else{
        inhibPercentage = 0;
    }

    shm_ptr[SHM_INHIB_PERCENTAGE] = inhibPercentage;
    
    //rimette ad 1 il semaforo 
    while (semop(shmSemId, &incSem, 1) == -1) {
        if(errno != EINTR){
            error("inibitore: Error in semop (postRead) semid = %d\t" , shmSemId);
            term(getppid() , GENERIC_ERR);
        }
    }
}

void readMsg(){
    struct msgBuffer msg;
    while(msgrcv(inhibMsgId , &msg , 3 * sizeof(int) , 0 , IPC_NOWAIT) == -1){
        switch(errno){
            case ENOMSG:
                error("inibitore: no message in queue");
                term(getppid() , GENERIC_ERR);
                break;
            case EINTR:
                break;
            default:
                error("inibitore: error in msgrcv()");
                term(getppid() , GENERIC_ERR);
                break;
        }
    }
    calcActivation(msg.mtext[0] , msg.mtext[1] , msg.mtext[2]);
}

void activationHandler(int sig , siginfo_t* info , void* ucontext){
    if(sig == SIGUSR1){
        if(inhib_status != info->si_int){
            inhib_status = info->si_int;
            if(writeLog(logFd , inhib_status ? "Inhibitor enabled\n" : "Inhibitor disabled\n") == -1){
                error("inibitore: writeLog()");
                term(getppid() , GENERIC_ERR);
            }
        }
        readMsg();
    }
}

int main(int argc , char** argv){
    inhib_status = atoi(argv[1]);
    logFd = atoi(argv[2]);

    struct sigaction sa;
    sa.sa_sigaction = activationHandler;
    sigemptyset(&(sa.sa_mask));
    sa.sa_flags = SA_SIGINFO;
    
    if(sigaction(SIGUSR1 , &sa , NULL) == -1){
        error("inibitore: sigaction() 1");
        term(getppid() , GENERIC_ERR);
    } 

    if(writeLog(logFd , "The inhibitor was created\n") == -1){
        error("inibitore: writeLog()");
        term(getppid() , GENERIC_ERR);
    }

    //creo un set di semafori 
    int statusSem = semget(ftok("./master",'A') , 2 , 0);
    if(statusSem == -1){
        error("inibitore: semget() 1");
        term(getppid() , GENERIC_ERR);
    }
    shmSemId = semget(ftok("./master", 'C'), 1, 0);
    if (shmSemId == -1){
        error("inibitore: semget() 2");
        term(getppid() , GENERIC_ERR);
    } 

    if((inhibMsgId = msgget(ftok("./inibitore" , 1) , 0)) == -1){
        error("master: msgget()");
        term(getppid() , GENERIC_ERR);
    }

    int shmId = shmget(ftok("./master", 'D'), 0 , 0);
    if(shmId == -1){
        error("inibitore: shmget()");
        term(getppid() , GENERIC_ERR);
    }

    //collego la shared
    shm_ptr = (int*)shmat(shmId, NULL, 0);
    if (shm_ptr == (int*)-1) {
        error("inibitore: shmat()");
        term(getppid() , GENERIC_ERR);
    }

    n_atom_init = getEnvInt("N_ATOMI_INIT");
    explode_threshold = getEnvInt("ENERGY_EXPLODE_THRESHOLD");
    new_atoms_each_second = (SECOND / getEnvInt("STEP_ALIMENTAZIONE")) * getEnvInt("N_NUOVI_ATOMI");
    atomic_sum_created_each_second = ((1 + getEnvInt("MAX_N_ATOMICO")) / 2) * new_atoms_each_second;

    calcActivation(0 , 0 , 0);

    // dice al master che Ã¨ pronto
    struct sembuf ready = {0 , 1 , 0};
    semop(statusSem , &ready , 1);
   
    // aspetta che il master dia il via
    struct sembuf waitForStart = {1 , 0 , 0};
    semop(statusSem , &waitForStart , 1);

    while(1) (void)pause();
}